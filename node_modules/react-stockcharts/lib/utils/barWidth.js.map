{"version":3,"sources":["../../../src/lib/utils/barWidth.js"],"names":["plotDataLengthBarWidth","timeIntervalBarWidth","props","moreProps","widthRatio","xScale","range","l","r","totalWidth","Math","abs","domain","dl","dr","width","interval","xAccessor","plotData","first","offset"],"mappings":";;;;;;;;QAWgBA,sB,GAAAA,sB;QAkBAC,oB,GAAAA,oB;;AA3BhB;;AAEA;;;;;;;AAOO,SAASD,sBAAT,CAAgCE,KAAhC,EAAuCC,SAAvC,EAAkD;AAAA,KAChDC,UADgD,GACjCF,KADiC,CAChDE,UADgD;AAAA,KAEhDC,MAFgD,GAErCF,SAFqC,CAEhDE,MAFgD;;AAAA,qBAIzCA,OAAOC,KAAP,EAJyC;AAAA;AAAA,KAIjDC,CAJiD;AAAA,KAI9CC,CAJ8C;;AAKxD,KAAMC,aAAaC,KAAKC,GAAL,CAASH,IAAID,CAAb,CAAnB;;AALwD,sBAMvCF,OAAOO,MAAP,EANuC;AAAA;AAAA,KAMjDC,EANiD;AAAA,KAM7CC,EAN6C;;AAQxD,KAAMC,QAAQN,aAAaC,KAAKC,GAAL,CAASE,KAAKC,EAAd,CAA3B;;AAEA,QAAOC,QAAQX,UAAf;AACA;;AAED;;;;;AAKO,SAASH,oBAAT,CAA8Be,QAA9B,EAAwC;AAC9C,QAAO,UAASd,KAAT,EAAgBC,SAAhB,EAA2B;AAAA,MACzBC,UADyB,GACVF,KADU,CACzBE,UADyB;AAAA,MAEzBC,MAFyB,GAEOF,SAFP,CAEzBE,MAFyB;AAAA,MAEjBY,SAFiB,GAEOd,SAFP,CAEjBc,SAFiB;AAAA,MAENC,QAFM,GAEOf,SAFP,CAENe,QAFM;;;AAIjC,MAAMC,QAAQF,UAAU,iBAAKC,QAAL,CAAV,CAAd;AACA,SAAOR,KAAKC,GAAL,CAASN,OAAOW,SAASI,MAAT,CAAgBD,KAAhB,EAAuB,CAAvB,CAAP,IAAoCd,OAAOc,KAAP,CAA7C,IAA8Df,UAArE;AACA,EAND;AAOA","file":"barWidth.js","sourcesContent":["\n\nimport { head } from \"../utils\";\n\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\nexport function plotDataLengthBarWidth(props, moreProps) {\n\tconst { widthRatio } = props;\n\tconst { xScale } = moreProps;\n\n\tconst [l, r] = xScale.range();\n\tconst totalWidth = Math.abs(r - l);\n\tconst [dl, dr] = xScale.domain();\n\n\tconst width = totalWidth / Math.abs(dl - dr);\n\n\treturn width * widthRatio;\n}\n\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\nexport function timeIntervalBarWidth(interval) {\n\treturn function(props, moreProps) {\n\t\tconst { widthRatio } = props;\n\t\tconst { xScale, xAccessor, plotData } = moreProps;\n\n\t\tconst first = xAccessor(head(plotData));\n\t\treturn Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\n\t};\n}\n"]}